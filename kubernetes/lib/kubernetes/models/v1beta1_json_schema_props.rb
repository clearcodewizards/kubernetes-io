# frozen_string_literal: true

# #Kubernetes
#
# No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
#
# OpenAPI spec version: v1.13.4
#
# Generated by: https://github.com/swagger-api/swagger-codegen.git
# Swagger Codegen version: 2.2.3
#

require 'date'

module Kubernetes
  # JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/).
  class V1beta1JSONSchemaProps
    attr_accessor :ref, :schema, :all_of, :any_of, :definitions, :dependencies, :description,
                  :enum, :exclusive_maximum, :exclusive_minimum, :external_docs, :format, :id, :max_items, :max_length, :max_properties, :maximum, :min_items, :min_length, :min_properties, :minimum, :multiple_of, :_not, :one_of, :pattern, :pattern_properties, :properties, :required, :title, :type, :unique_items

    # JSONSchemaPropsOrBool represents JSONSchemaProps or a boolean value. Defaults to true for the boolean property.
    attr_accessor :additional_items

    # JSONSchemaPropsOrBool represents JSONSchemaProps or a boolean value. Defaults to true for the boolean property.
    attr_accessor :additional_properties

    # JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil.
    attr_accessor :default

    # JSON represents any valid JSON value. These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil.
    attr_accessor :example

    # JSONSchemaPropsOrArray represents a value that can either be a JSONSchemaProps or an array of JSONSchemaProps. Mainly here for serialization purposes.
    attr_accessor :items

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        ref: :$ref,
        schema: :$schema,
        additional_items: :additionalItems,
        additional_properties: :additionalProperties,
        all_of: :allOf,
        any_of: :anyOf,
        default: :default,
        definitions: :definitions,
        dependencies: :dependencies,
        description: :description,
        enum: :enum,
        example: :example,
        exclusive_maximum: :exclusiveMaximum,
        exclusive_minimum: :exclusiveMinimum,
        external_docs: :externalDocs,
        format: :format,
        id: :id,
        items: :items,
        max_items: :maxItems,
        max_length: :maxLength,
        max_properties: :maxProperties,
        maximum: :maximum,
        min_items: :minItems,
        min_length: :minLength,
        min_properties: :minProperties,
        minimum: :minimum,
        multiple_of: :multipleOf,
        _not: :not,
        one_of: :oneOf,
        pattern: :pattern,
        pattern_properties: :patternProperties,
        properties: :properties,
        required: :required,
        title: :title,
        type: :type,
        unique_items: :uniqueItems
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        ref: :String,
        schema: :String,
        additional_items: :Object,
        additional_properties: :Object,
        all_of: :'Array<V1beta1JSONSchemaProps>',
        any_of: :'Array<V1beta1JSONSchemaProps>',
        default: :Object,
        definitions: :'Hash<String, V1beta1JSONSchemaProps>',
        dependencies: :'Hash<String, Object>',
        description: :String,
        enum: :'Array<Object>',
        example: :Object,
        exclusive_maximum: :BOOLEAN,
        exclusive_minimum: :BOOLEAN,
        external_docs: :V1beta1ExternalDocumentation,
        format: :String,
        id: :String,
        items: :Object,
        max_items: :Integer,
        max_length: :Integer,
        max_properties: :Integer,
        maximum: :Float,
        min_items: :Integer,
        min_length: :Integer,
        min_properties: :Integer,
        minimum: :Float,
        multiple_of: :Float,
        _not: :V1beta1JSONSchemaProps,
        one_of: :'Array<V1beta1JSONSchemaProps>',
        pattern: :String,
        pattern_properties: :'Hash<String, V1beta1JSONSchemaProps>',
        properties: :'Hash<String, V1beta1JSONSchemaProps>',
        required: :'Array<String>',
        title: :String,
        type: :String,
        unique_items: :BOOLEAN
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.transform_keys(&:to_sym)

      self.ref = attributes[:$ref] if attributes.key?(:$ref)

      self.schema = attributes[:$schema] if attributes.key?(:$schema)

      self.additional_items = attributes[:additionalItems] if attributes.key?(:additionalItems)

      if attributes.key?(:additionalProperties)
        self.additional_properties = attributes[:additionalProperties]
      end

      if attributes.key?(:allOf) && (value = attributes[:allOf]).is_a?(Array)
        self.all_of = value
      end

      if attributes.key?(:anyOf) && (value = attributes[:anyOf]).is_a?(Array)
        self.any_of = value
      end

      self.default = attributes[:default] if attributes.key?(:default)

      if attributes.key?(:definitions) && (value = attributes[:definitions]).is_a?(Array)
        self.definitions = value
      end

      if attributes.key?(:dependencies) && (value = attributes[:dependencies]).is_a?(Array)
        self.dependencies = value
      end

      self.description = attributes[:description] if attributes.key?(:description)

      if attributes.key?(:enum) && (value = attributes[:enum]).is_a?(Array)
        self.enum = value
      end

      self.example = attributes[:example] if attributes.key?(:example)

      self.exclusive_maximum = attributes[:exclusiveMaximum] if attributes.key?(:exclusiveMaximum)

      self.exclusive_minimum = attributes[:exclusiveMinimum] if attributes.key?(:exclusiveMinimum)

      self.external_docs = attributes[:externalDocs] if attributes.key?(:externalDocs)

      self.format = attributes[:format] if attributes.key?(:format)

      self.id = attributes[:id] if attributes.key?(:id)

      self.items = attributes[:items] if attributes.key?(:items)

      self.max_items = attributes[:maxItems] if attributes.key?(:maxItems)

      self.max_length = attributes[:maxLength] if attributes.key?(:maxLength)

      self.max_properties = attributes[:maxProperties] if attributes.key?(:maxProperties)

      self.maximum = attributes[:maximum] if attributes.key?(:maximum)

      self.min_items = attributes[:minItems] if attributes.key?(:minItems)

      self.min_length = attributes[:minLength] if attributes.key?(:minLength)

      self.min_properties = attributes[:minProperties] if attributes.key?(:minProperties)

      self.minimum = attributes[:minimum] if attributes.key?(:minimum)

      self.multiple_of = attributes[:multipleOf] if attributes.key?(:multipleOf)

      self._not = attributes[:not] if attributes.key?(:not)

      if attributes.key?(:oneOf) && (value = attributes[:oneOf]).is_a?(Array)
        self.one_of = value
      end

      self.pattern = attributes[:pattern] if attributes.key?(:pattern)

      if attributes.key?(:patternProperties) && (value = attributes[:patternProperties]).is_a?(Array)
        self.pattern_properties = value
      end

      if attributes.key?(:properties) && (value = attributes[:properties]).is_a?(Array)
        self.properties = value
      end

      if attributes.key?(:required) && (value = attributes[:required]).is_a?(Array)
        self.required = value
      end

      self.title = attributes[:title] if attributes.key?(:title)

      self.type = attributes[:type] if attributes.key?(:type)

      return unless attributes.key?(:uniqueItems)

      self.unique_items = attributes[:uniqueItems]
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properies with the reasons
    def list_invalid_properties
      []
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      true
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        ref == other.ref &&
        schema == other.schema &&
        additional_items == other.additional_items &&
        additional_properties == other.additional_properties &&
        all_of == other.all_of &&
        any_of == other.any_of &&
        default == other.default &&
        definitions == other.definitions &&
        dependencies == other.dependencies &&
        description == other.description &&
        enum == other.enum &&
        example == other.example &&
        exclusive_maximum == other.exclusive_maximum &&
        exclusive_minimum == other.exclusive_minimum &&
        external_docs == other.external_docs &&
        format == other.format &&
        id == other.id &&
        items == other.items &&
        max_items == other.max_items &&
        max_length == other.max_length &&
        max_properties == other.max_properties &&
        maximum == other.maximum &&
        min_items == other.min_items &&
        min_length == other.min_length &&
        min_properties == other.min_properties &&
        minimum == other.minimum &&
        multiple_of == other.multiple_of &&
        _not == other._not &&
        one_of == other.one_of &&
        pattern == other.pattern &&
        pattern_properties == other.pattern_properties &&
        properties == other.properties &&
        required == other.required &&
        title == other.title &&
        type == other.type &&
        unique_items == other.unique_items
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(other)
      self == other
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [ref, schema, additional_items, additional_properties, all_of, any_of, default, definitions,
       dependencies, description, enum, example, exclusive_maximum, exclusive_minimum, external_docs, format, id, items, max_items, max_length, max_properties, maximum, min_items, min_length, min_properties, minimum, multiple_of, _not, one_of, pattern, pattern_properties, properties, required, title, type, unique_items].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            send("#{key}=", attributes[self.class.attribute_map[key]].map do |v|
                              _deserialize(Regexp.last_match(1), v)
                            end)
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = Kubernetes.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = send(attr)
        next if value.nil?

        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
